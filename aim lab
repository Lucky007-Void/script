local player = game.Players.LocalPlayer
local uis = game:GetService("UserInputService")
local runService = game:GetService("RunService")
local camera = workspace.CurrentCamera

local locking = false
local targetPart = nil
local FOV = 500
local smoothness = 0.5

local fovCircle = Drawing.new("Circle")
fovCircle.Visible = true
fovCircle.Thickness = 2
fovCircle.Color = Color3.fromRGB(255, 255, 255)
fovCircle.Radius = FOV
fovCircle.Filled = false
fovCircle.Position = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)

-- **[1] ฟังก์ชันตรวจสอบว่ามีผนังกั้นหรือไม่ (ไม่ทะลุกำแพง)**
local function canSee(targetPosition)
    local rayOrigin = camera.CFrame.Position
    local rayDirection = (targetPosition - rayOrigin).Unit * (targetPosition - rayOrigin).Magnitude
    local raycastParams = RaycastParams.new()
    -- กรอง Character ของผู้เล่นออกจากการ Raycast
    raycastParams.FilterDescendantsInstances = {player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    if raycastResult then
        -- ตรวจสอบว่าจุดที่ Raycast ชนนั้น ใกล้เคียงกับตำแหน่งเป้าหมายหรือไม่
        -- ถ้าใกล้เคียง แสดงว่าไม่มีอะไรบัง
        return raycastResult.Position:FuzzyEq(targetPosition, 0.1)
    end
    -- ถ้า Raycast ไม่ชนอะไรเลย ก็ถือว่าเห็น
    return true
end

-- **[2] ฟังก์ชันหา Part 'Target' ที่ใกล้กลางหน้าจอที่สุดใน FOV**
local function getClosestTargetInFOV()
    local closest = nil
    local closestDist = FOV

    local center = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)

    for _, part in pairs(workspace:GetDescendants()) do
        if part.Name == "Target" and part:IsA("BasePart") then
            local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local dist = (center - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                -- **เพิ่มเงื่อนไข: ต้องสามารถมองเห็นได้ (canSee)**
                if dist < closestDist and canSee(part.Position) then
                    closest = part
                    closestDist = dist
                end
            end
        end
    end

    return closest
end

uis.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.V then
        locking = true
    end
end)

uis.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.V then
        locking = false
        targetPart = nil
    end
end)

runService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
    fovCircle.Radius = FOV

    if locking then
        targetPart = getClosestTargetInFOV()
        
        if targetPart then
            local currentCFrame = camera.CFrame
            local targetCFrame = CFrame.new(currentCFrame.Position, targetPart.Position)
            camera.CFrame = currentCFrame:Lerp(targetCFrame, smoothness)
        end
    end
end)
